---
title: 事件循环机制
date: 2019-12-30 21:06:23
tags:
categories:
---

事件循环（`event loop`），是用于处理JavaScript运行中发生单线程阻塞的一种机制。事件循环在不同环境下的处理方式也略有不同。在浏览器环境下，微任务队列是每个宏执行完之后执行。而在Node中，微任务会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行微任务队列的任务。

## 浏览器中的 Event Loop

JavaScript是单线程,需要排队执行代码，实现排队的方式，就是`Event Loop`。JavaScript是单线程，但浏览器并不是单线程。浏览器的线程有以下:

- JavaScript线程
- GUI线程
- 事件触发线程
- 定时器线程
- 异步http线程
- ...

浏览器的设置中，`GUI渲染线程`与`JavaScript引擎`是为互斥的关系，所以当GUI线程在渲染的时候，JavaScript线程会挂起，等待`GUI线程`完成，然后再执行`JavaScript线程`。JavaScript会存在执行栈，从上至下执行JavaScript代码，当遇到异步api时,列如上面所述的各种非JavaScript线程的事件，那么会扔给对应的线程去处理，等处理完毕后，则把回调函数放入事件队列中，等待执行栈执行完毕，再去读取事件队列中的回调函数执行。
每当一个函数执行，会产生一个新的执行栈，当执行完毕返回上一层执行栈,直到回到全局执行栈。
每当一个函数调用自己，会产生一个新的执行栈。

### 宏任务与微任务

浏览器端事件循环中的异步队列有两种：宏任务队列和微任务队列。
宏任务队列可以有多个，微任务队列只有一个。
> 常见的宏任务：setTimeout、setInterval、script、 I/O 操作、UI 渲染等。
> 常见的微任务: new Promise().then()、MutationObserver() 等

### 浏览器中的事件循环过程解析

当某一个宏任务执行完后,浏览器会查看是否存在微任务队列。如果存在，就会先执行在微任务队列里的所有任务，如果没有的话，会读取宏任务队列中排在最靠前的任务，执行宏任务的过程中，一旦有微任务，就依次加入到微任务队列当中。如果栈空了，下一次依次微任务队列里的任务，循环往复。
一个完整的 `Event Loop` 过程，可以概括为以下阶段：
* 一开始执行栈空,我们可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。微任务队列空，宏任务队列里有且只有一个 script 脚本。
* 全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的宏任务与微任务，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 宏任务队列，这个过程本质上是队列的 宏任务 的执行和出队的过程。
* 上一步我们出队的是一个 宏任务，这一步我们处理的是微任务。但需要注意的是：当宏任务出队时，任务是一个一个执行的；而微任务出队时，任务是一队一队执行的。所以，我们处理微任务队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。
* 执行渲染操作，更新界面
* 检查是否存在Web worker任务，如果有，则对其进行处理
* 上述过程循环往复，直到两个队列都清空


## Node中的 Event Loop

Node.js 是一个基于事件的平台。这意味着在 Node 中发生的一切都是基于对事件的反应。通过 Node 的事件处理机制遍历一系列回调。事件的回调，这一切都由一个名为 `libuv` 的库来处理，它提供了一种称为事件循环的机制。

### 常见的误解

`Libuv` 是向 `Node.js` 提供事件循环的库。在 `libuv` 背后的关键人物 `Bert Belder` 的精彩的演讲中，演讲开头他使用 Google 图例如搜索展示了各种不同方式描述事件循环的图片，但是他指出大部分图片描绘的都是错误的。

1. 在用户代码中，事件循环在单独的线程中运行
2. 异步的所有内容都由线程池处理
3. 事件循环类似栈或队列

首先在主线程上面运行用户的 JavaScript 代码，而另开一个线程的运行事件循环。每次如果有异步操作发生，主线程就将把工作交给事件循环线程。一旦线程完成，事件循环线程将会再通知主线程执行回调。只有一个线程执行 JavaScript 代码，在这个线程上面同时运行事件循环。回调的执行(在运行的 Node.js 应用程序中被传入、后又被调用的代码都是一个回调)是由事件循环完成地。稍后我们会深入讨论。

异步操作，例如操作文件系统，向外发送 HTTP 请求以及与数据库通信等都是由 `libuv`提供的线程池处理的。`Libuv` 默认使用四个线程创建一个线程池来完成异步工作。今天的操作系统已经为许多 I/O 任务提供了异步接口。
只要有可能，`libuv`将使用这些异步接口，避免使用线程池。
这同样适用于例如数据库这样的第三方子系统。在这里，驱动程序的作者宁愿使用异步接口，而不是使用线程池。
`只有没有其他方式可以使用时，线程池才将会被用于异步 I/O 。`

虽然涉及到类似队列的结构，事件循环并不是采用栈的方式处理任务。事件循环作为一个进程被划分为多个阶段，每个阶段处理一些特定任务，各阶段轮询调度。事件循环采用先进先出的方式执行异步任务，类似于队列，当一个任务执行完毕后调用对应的回调函数。

### 事件循环周期的阶段

事件循环的执行可以分成以下 5 个阶段。

#### 计时器

通过 `setTimeout()` 和 `setInterval()` 注册的回调会在此处处理。

#### IO 回调

大部分回调将在这部分被处理。Node.js 中大多数用户代码都在回调中处理(例如，对传入的 http 请求触发级联的回调)。

#### IO 轮询

对接着要处理的的事件进行新的轮询。

#### Immediate 设置

此处处理所有由 `setImmediate()` 注册的回调。

#### 结束

这里处理所有‘结束’事件的回调。

### 监测事件循环

我们看到，事实上在 Node 应用程序中进行的所有事件都将通过事件循环运行。
这意味着如果我们可以从中获得指标，相应地我们可以分析出对应的应用程序整体运行状况和性能的宝贵信息。

从事件循环中获取运行时的指标没有现成的API，所以每个监控工具都提供自己的指标，我们可以来看看具体是哪些。

- 记录频率: 每次的记录数。
- 记录持续时间:一个刻度的时间。由于我们的代理作为本机模块运行，所以这是比较容易地添加探测器为我们提供这些信息。
- 记录频率以及记录持续事件指标
- 事件循环持续时间和被动态调整频率

如果当应用程序是处于空闲状态，这就说明没有执行任何任务(定时器、回调等)，此时全速运行这些阶段是没有意义的，事件循环就这种情况会在在轮询阶段阻塞一段时间以等待新的外部事件进入。

这也意味着，无负载下的度量(低频，高持续时间)与在高负载下与慢后端相关的应用程序相似。

**所以，标记频率和标记持续时间需要基于每秒并发请求量进行度量。**

##### 工作处理延迟

这个度量衡量线程池处理异步任务所需的时间。

高工作处理的延迟表示一个繁忙/耗尽的线程池。


##### 事件循环延迟

事件循环延迟测量在通过 `setTimeout()` 调度的任务真正得到处理之前需要多长时间。

事件循环高延迟表示事件循环正忙于处理回调。这些需求仍然需要在更大的图片中去观察，以使其有意义。所以，我们正在收集信息以将这些数据纳入我们的异常检测。

当然，在不了解如何从可能的行动中解决问题的情况下，衡量标准本身就不会有太大的帮助。当事件循环快耗尽时，这里有几个提示。

事件循环耗尽

#### 利用可用CPU

Node.js 应用程序在单个线程上运行。在多核机器上，这意味着负载不会分布在所有内核上。使用 Node 附带的 [cluster module](https://nodeJavaScript.org/api/cluster.html) 可以轻松地为每个 CPU 生成一个子进程。每个子进程维护自己的事件循环，主进程在所有子进程之间透明地分配负载。

#### 线程池调整

`libuv` 将创建一个大小为 4 的线程池。通过设置环境变量 `UV_THREADPOOL_SIZE` 可以覆盖线程池的默认大小。

虽然这可以解决 I/O 绑定应用程序上的负载问题，建议多次负载测试，因为较大的线程池可能仍然耗尽内存或 CPU 。

#### 任务进入服务进程

如果 Node.js 花费太多时间参与 CPU 繁重的操作，开一些服务进程处理这些繁重任务或者针对某些特定任务使用其它语言编写服务也是一个可行的选择。

### 总结

- 事件循环是让 Node.js 应用程序顺利运行的原因
- 它的功能经常被误解：它有多个阶段组成，各阶段处理特定任务，阶段间轮询调度
- 事件循环不提供现成的指标，所以在 APM 供应商之间收集的指标是不同的
- 这些指标清楚地提供了有关瓶颈的有价值的见解，但关键是对事件循环的深刻理解以及正在运行的代码
- 在未来，Dynatrace 将会把事件循环添加到第一检测要素，从而将事件循环异常与问题相关联


> 参考文章
[《understand the node JavaScript event loop and its metrics》](https://www.dynatrace.com/news/blog/all-you-need-to-know-to-really-understand-the-node-JavaScript-event-loop-and-its-metrics/)
[《event loop timers and nexttick》](https://nodeJavaScript.org/en/docs/guides/event-loop-timers-and-nexttick/)


