---
title: http协议
date: 2017-05-10 09:37:26
tags: [http]
categories: 知识点
---

浏览器的渲染过程。
一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？

<div align=center>
![“封面”](/images/bg/0026.jpeg)
</div>
<!--more-->

# 浏览器的渲染过程
1. 浏览器请求到HTML代码后，在生成DOM的最开始阶段，并行发起css、图片、js的请求，无论他们是否在HEAD里。浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。
2. CSS文件下载完成，开始构建CSSOM
3. 所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。
4. 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作就是计算出每个节点在屏幕中的位置。
5. 最后一步，按照算出来的规则，把内容渲染到屏幕上。
以上五个步骤前3个步骤因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。Layout 和 Painting 也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。
> display:none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为 display:none 是更优的。

# 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？
1. 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求（TCP三次握手）；
2. 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；
3. 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；
4. 载入解析到的资源文件，渲染页面，完成

# 一个完整的URL包括以下几部分
`http://www.baidu.net:8080/news/index.php?boardID=5&ID=24618&page=1#name`
1、协议部分
2、域名部分
3、端口部分
4、虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止
5、文件名部分：从域名后的最后一个“/”开始到“？”为止
6、参数部分：从“？”开始到“#”为止之间的部分
7、锚部分：从“#”开始到最后

# 一次完整的http请求：
1. 建立TCP连接
2. Web浏览器向Web服务器发送请求命令 
3. Web浏览器发送请求头信息 
4. Web服务器应答 
5. Web服务器发送应答头信息
6. Web服务器向浏览器发送数据 
7. Web服务器关闭TCP连接

## HTTP请求四部分
1、HTTP请求的方法或动作，比如是get还是post请求；
2、正在请求的URL（请求的地址）；
3、请求头，包含一些客户端环境信息、身份验证信息等；
4、请求体（请求正文），可以包含客户提交的查询字符串信息、表单信息等。

### 请求头字段：
Accept:text/html,image/*(告诉服务器，浏览器可以接受文本，网页图片)
Accept-Charaset:ISO-8859-1 [接受字符编码：iso-8859-1]
Accept-Encoding:gzip,compress[可以接受 gzip,compress压缩后数据]
Accept-Language:zh-cn[浏览器支持的语言]
Host:localhost:8080[浏览器要找的主机]
If-Modified-Since:Tue, 09 May 2017 01:34:02 GMT[告诉服务器我这缓存中有这个文件,该文件的时间是…]
User-Agent:Nozilla/4.0(Com…)[告诉服务器我的浏览器内核，客户端环境信]
Cookie：[身份验证信息]
Connection:close/Keep-Alive [保持链接，发完数据后，我不关闭链接]

## HTTP响应三部分
1、一个数字和文字组成的状态码，用来显示请求是成功还是失败；
2、响应头，响应头也和请求头一样包含许多有用的信息，例如服务器类型、日期时间、内容类型和长度等；
3、响应体（响应正文）。

### 响应头字段：
CacheControl:[告诉浏览器如何缓存页面(因为浏览器的兼容性最好设置两个)]
Connection:close/Keep-Alive [保持链接，发完数据后，我不关闭链接]
Content-Type:text/html;charset=gb2312[内容格式和编码]
Last-Modified:Tue,11 Juj,2017 18 18:29:20[告诉浏览器该资源上次更新时间是多少]
ETag:”540-54f0d59b8b680”
Expires:Fri, 26 May 2017 13:28:33 GMT [失效日期]
server:apache tomcat nginx [哪种服务器]
# 说说TCP传输的三次握手
第一次握手，客户端给服务器发送数据包（带SYN标志的数据包）。此时服务器确认自己可以接收客户端的包，而客户端不确认服务器是否接收到了自己发的数据包。
第二次握手，服务器端回复（回传一个带有SYN/ACK标志的数据包以示传达确认信息）客户端。此时客户端确认自己发的包被服务器收到，也确认自己可以正常接收服务器包，客户端对此次通信没有疑问了。服务器也可以确认自己能接收到客户端的包，但不能确认客户端能否接收自己发的包。
第三次握手，客户端回复（发送端再回传一个带ACK标志的数据包，代表“握手”结束）服务器。 客户端已经没有疑问了，服务器也确认刚刚客户端收到了自己的数据包。两边都没有问题，开始通信。
## 为什么要三次握手：
为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。也防止了服务器端的一直等待而浪费资源
TCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！
# 四次挥手
1、主机向服务器发送一个断开连接的请求（ 不早了，我该走了 ）,发送一个FIN报文段；
2、服务器接到请求后发送确认收到请求的信号（ 知道了 ）回一个ACK报文段；
3、服务器向主机发送断开通知（ 我也该走了 ）发送FIN报文段，请求关闭连接；
4、主机接到断开通知后断开连接并反馈一个确认信号（ 嗯，好的 ），服务器收到确认信号后也断开连接；
# 常见HTTP状态码
1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。
2xx（成功）表示成功处理了请求的状态码。
200（成功）：服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。
3xx（重定向）要完成请求，需要进一步操作。
301（永久移动）：请求的网页已永久移动到新位置。
302（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。
304（未修改）：自从上次请求后，请求的网页未修改过。
4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。
400（错误请求）：服务器不理解请求的语法。
404（未找到）：服务器找不到请求的网页。
5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。
500（服务器内部错误）：服务器遇到错误，无法完成请求。
503（服务不可用）：服务器目前无法使用（由于超载或停机维护）。
# 讲讲304缓存的原理
服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。
304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件

